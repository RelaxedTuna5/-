% === Финальная версия: FFT-канализатор с выгрузкой целочисленных данных ===
clc;                                % Очищаем окно команд MATLAB, чтобы видеть только новый вывод
clear;                              % Удаляем все переменные из рабочего пространства
close all;                          % Закрываем все открытые графические окна

% --- 1. Параметры системы ---
fs         = 10e6;                 % Частота дискретизации входного сигнала в герцах (10 МГц)
M          = 4;                    % Количество субканалов (ветвей полифазного анализатора)
signalLen  = 8192;                 % Длина тестового сигнала (должна быть кратна M)

% --- 2. Параметры экспорта в RTL ---
W           = 16;                  % Глубина фиксированной разрядности (бит на слово)
max_int_val = 2^(W-1) - 1;         % Максимальное представимое целое значение (без знака)

% --- 3. Прототип FIR-фильтра ---
LpfLen = 128;                      % Число коэффициентов FIR-фильтра
beta   = 8;                        % Параметр окна Кайзера для проектирования фильтра
h      = fir1(LpfLen-1, 1/M, kaiser(LpfLen, beta)) * M;
                                   % Создаем низкочастотный FIR-фильтр 
                                   % с нормированной частотой среза 1/M и масштабируем его на M

% --- 4. Полифазное разложение FIR-фильтра ---
P      = ceil(LpfLen / M);        % Число строк в матрице полиразложения (количество коэффициентов на ветвь)
h_pad  = [h(:); zeros(P*M - LpfLen, 1)];
                                   % Дополняем вектор коэффициентов нулями, чтобы его длина стала ровно P*M
H_poly = reshape(h_pad, M, P).';   % Формируем P×M матрицу подфаз (транспонируем для удобства умножения)

% --- 5. Генерация тестового комплексного сигнала ---
f_test = [0.5e6, -3.5e6, 4.5e6];   % Массив тестовых несущих частот (Гц)
t      = (0:signalLen-1)' / fs;    % Временная ось (секунды), столбцовый вектор
A_test = [1 0.5 0.25];

x  = A_test(1) * exp(1j * 2 * pi * t * f_test(1));
for f = 2 : length(f_test)
    x = x + A_test(f) * exp(1j * 2 * pi * t * f_test(f));
end
 
                                   % Сумма трех комплексных синусоид:
                                   % exp(j·2π·f_i·t), каждая ветвь добавляется в общий сигнал

% --- 6. Полифазная фильтрация + FFT по блокам длины M ---
numFrames = signalLen / M;         % Число «кадров» (блоков) по M отсчетов
reg       = zeros(P, M);           % Сдвиговый регистр для P прошлых значений каждой ветви
V_out     = zeros(M, numFrames);   % Матрица выходных спектров: M строк × numFrames столбцов

for n = 1:numFrames
    reg(1:end-1, :) = reg(2:end, :);           % Сдвигаем всю историю каждой ветви вверх
    reg(end, :)     = x((n-1)*M + (1:M)).';   % В последнюю строку записываем новые M отсчетов
    v               = sum(reg .* H_poly, 1);  % поэлементное произведение + суммирование → 1×M
    V_out(:, n)     = fft(v, M).';            % M-точечный FFT по полученным M значениям
end

% --- 7. Визуализация: полный спектр + субканалы ---
figure('Position', [100, 100, 1200, 800]);    % Создаем окно заданного размера
sgtitle(sprintf('%d-канальный канализатор', M), 'FontSize', 16);
                                              % Общий заголовок рисунка

% 7.1 Построение полного спектра исходного сигнала
subplot(3, 1, 1);
Xf_full = fftshift(fft(x));                   % Полный БПФ и центровка нуля по середине
f_full  = linspace(-fs/2, fs/2, signalLen);   % Ось частот от –fs/2 до +fs/2
plot(f_full/1e6, abs(Xf_full));               % Амплитудный спектр в МГц
grid on; title('Исходный спектр');
xlabel('Частота, МГц'); ylabel('Амплитуда');
xlim([-fs/2, fs/2]/1e6);

% 7.2 Построение спектров отдельных субканалов
sub_bw = fs / M;                              % Ширина каждой полосы субканала
f_sub  = linspace(-sub_bw/2, sub_bw/2, numFrames);
maxA   = 0;                                   % Инициализация для поиска глобального максимума
Ychan  = zeros(M, numFrames);                 % Для хранения амплитуд субканалов

for k = 1:M
    Bk          = fftshift(fft(V_out(k,:), numFrames), 2); % FFT и центровка k-го субканала
    Ychan(k,:)  = abs(Bk);                            % Амплитуда спектра
    maxA        = max(maxA, max(Ychan(k,:)));         % Обновляем общий максимум
end

for k = 1:M
    subplot(3, M, M + k);                             % Нижний ряд из M подграфиков
    plot(f_sub/1e6, Ychan(k,:));                      % Амплитуда k-го субканала
    grid on; title(sprintf('Канал %d', k));          
    xlabel('Частота, МГц');
    if k == 1
        ylabel('Амплитуда');                         % Подпись Y только для первого графика
    end
    xlim([-sub_bw/2, sub_bw/2]/1e6);                  
    ylim([0, maxA * 1.1]);                           % Единый масштаб по Y для всех каналов
end

% --- 8. Реконструкция спектра через субканалы  ---
% V_fft = fftshift( fft( V_out, numFrames, 2 ), 2 );  % По-строчно FFT + центровка
V_fft = fftshift(Ychan.', 2).';

% Склеиваем каналы в исходном порядке 1, 2, …, M
Y_rec = reshape( V_fft.', 1, []);                    % 1×signalLen

% Готовим ось частот для каждого блока 
f_rec = zeros(1, signalLen);
for k = 1:M
    f0         = -fs/2 + (k - 0.5) * sub_bw;        % Центр k-го блока в абсолютных Гц
    idx        = (k-1)*numFrames + (1:numFrames);  % Индексы для этого блока в Y_rec
    f_rec(idx) = f0 + f_sub;                       % Смещаем относительный вектор f_sub
end

% Отрисовка
subplot(3,1,3);
plot(f_rec/1e6, abs(circshift(Y_rec, -1024)), 'LineWidth', 1.2);
grid on;
title('Реконструированный спектр (натуральный порядок каналов)');
xlabel('Частота, МГц');
ylabel('Амплитуда');
xlim([-fs/2, fs/2]/1e6);




% --- 9. Экспорт целочисленных данных для RTL ---
% 9.1 Квантование и запись входного сигнала
max_abs_x = max(abs(x));                          % Находим абсолютный максимум для нормировки
xr        = round(real(x) / max_abs_x * max_int_val); % Квантование вещественной части
xi        = round(imag(x) / max_abs_x * max_int_val); % Квантование мнимой части
fid       = fopen('input_signal.txt', 'w');       % Открываем файл на запись
fprintf(fid, '%d %d\n', [xr, xi].');               % Записываем пары (реал, мним) построчно
fclose(fid);                                       % Закрываем файл

% 9.2 Квантование и запись коэффициентов фильтра
h_fixed   = round(h * max_int_val);                % Преобразуем вещественные коэф. в целые
h_pad_fix = [flipud(h_fixed(:)); zeros(P*M - length(h_fixed), 1, 'int16')];
                                                   % Переворачиваем и дополняем до P*M
Hp_fix    = reshape(h_pad_fix, M, P);              % Формируем матрицу полиразложения для RTL
fid       = fopen('coeffs.txt', 'w');
fprintf(fid, '%d\n', Hp_fix(:));                   % Записываем коэффициенты одна строка = один коэф.
fclose(fid);

% 9.3 Квантование и запись выходного сигнала (до БПФ)
V_vec     = V_out.';                               % Транспонируем для линейного списка
max_abs_v = max(abs(V_vec(:)));                    % Максимум для нормировки
vr        = round(real(V_vec) / max_abs_v * max_int_val);
vi        = round(imag(V_vec) / max_abs_v * max_int_val);
fid       = fopen('output_signal.txt', 'w');
fprintf(fid, '%d %d\n', [vr, vi].');
fclose(fid);

disp('Данные для RTL сохранены в файлы: input_signal.txt, coeffs.txt, output_signal.txt');
