#include <stdio.h>
#include <locale>
struct person {
	char name[10];
	char surname[10];
	int phone;
} P[100] = { "Ivan", "Ivanov", 245 };

// объявление структуры person и массива P с 100 элементами, где каждый элемент имеет поля name, surname и phone, которые могут быть только соответствующего типа

char areEqual(char* s1, char* s2) {
	int n = 0;
	while (s1[n] + s2[n] != 0 && s1[n] == s2[n]) n++;  // сравнение символов строк s1 и s2 посимвольно пока они не закончатся или не будет найдено первое несовпадение
	return (s1[n] == '\0' && s2[n] == '\0');  // если строки s1 и s2 одинаковые, функция возвращает true
}

// функция, которая сравнивает две строки и возвращает true, если они одинаковые

int strToNum(char* s) {
	int i = 0, ans = 0;
	while (s[i] != '\0') {
		ans = ans * 10 + s[i] - 48;  // преобразование строки s в число
		i++;
	}
	return ans;  // функция возвращает полученное число
}
void findLineDB(FILE* f, int dbSize) {
	char temp[10]; // создаем переменную temp, которая будет использоваться для хранения введенного пользователем значения для поиска
	person db; // создаем переменную db типа person, которая будет использоваться для чтения данных из файла f
	scanf_s("%s", temp, 10); // считываем значение, указанное пользователем для поиска, из консоли и записываем его в переменную temp
	fseek(f, 0, SEEK_SET); // перемещаем указатель файла на начало
	for (int i = 0; i < dbSize; i++) { // для каждой записи в базе данных
		fread(&db, sizeof(person), 1, f); // считываем значения текущей записи из файла f в переменную db
		if (areEqual(temp, db.name) || areEqual(temp, db.surname) || strToNum(temp) == db.phone) { // проверяем, соответствует ли значение, указанное пользователем для поиска, значениям в текущей записи
			printf("%d | %s\t%s\t%d\n", i + 1, db.name, db.surname, db.phone);
		}
	}
}

void addLineDB(FILE* db, int* dbSize) {  // объявление функции с двумя параметрами
	person temp;                        // создание временной переменной типа person
	printf("Имя(латиницей):");         // вывод на экран запроса имени
	scanf_s("%s", temp.name, 10);       // считывание имени, введённого пользователем, и сохранение его в поле name struct person
	printf("Фамилия(латиницей):");     // вывод на экран запроса фамилии
	scanf_s("%s", temp.surname, 10);    // считывание фамилии, введённой пользователем, и сохранение её в поле surname структуры temp
	printf("Номер:");                  // вывод на экран запроса номера телефона
	scanf_s("%d", &temp.phone);         // считывание номера телефона, введённого пользователем, и сохранение его в в поле phone структуры temp
	fseek(db, sizeof(temp) * (*dbSize), SEEK_SET);   // перемещение указателя файла на конец базы данных
	fwrite(&temp, sizeof(temp), 1, db);           // запись новой записи в конец базы данных
	*dbSize = *dbSize + 1;               // увеличение значения dbSize на единицу (количество записей в базе данных)
}



void printDB(FILE* f, int dbSize) { // функция вывода содержимого базы данных на экран
	person db; // создание переменной db типа person, которая будет использоваться для чтения данных из файла f
	fseek(f, 0, SEEK_SET); // перемещаем указатель файла на начало
	for (int i = 0; i < dbSize; i++) { // для каждой записи в базе данных
		fread(&db, sizeof(person), 1, f); // считываем данные из файла f в переменную db
		printf("%d | %s\t%s\t%d\n", i + 1, db.name, db.surname, db.phone); // выводим на экран данные данной записи, разделенные табуляцией
	}
}


void editLineDB(FILE* f, int dbSize) { // функция изменения строки в базе данных f
	int lineNum, actionNum; // переменные, которые хранят номер изменяемой строки и выбранный пользователем номер действия
	printf("Укажите номер строчки:"); // вывод сообщения на экран, запрашивающего номер изменяемой строки
	do { // цикл, который продолжается до тех пор, пока пользователь не введет номер существующей строки
		scanf_s("%d", &lineNum); // чтение номера изменяемой строки, введенного пользователем, и сохранение в переменной lineNum
		if (lineNum > dbSize) printf("введите номер существующей строчки\n:"); // если пользователь ввел номер, который превышает количество строк в базе данных, выводим сообщение об ошибке
	} while (lineNum > dbSize || lineNum < 0); // повторяем цикл, если пользователь ввел некорректный номер строки

	printf("Укажите что хотите изменить\n1)Имя\n2)Фамилия\n3)Номер\n"); // вывод сообщения на экран, запрашивающего пользователем, какое поле записи нужно изменить

	fseek(f, sizeof(person) * (lineNum - 1), SEEK_SET); // перемещение указателя файла на начало изменяемой записи
	person db; // создание переменной db типа person, которая будет использоваться для чтения и записи значений полей записи
	fread(&db, sizeof(person), 1, f); // чтение значений полей текущей записи из файла f в переменную db
	fseek(f, -24, SEEK_CUR); // перемещение указателя файла на начало поля, которое нужно изменить

	do { // цикл, который продолжается до тех пор, пока пользователь не выберет корректный номер действия
		printf(":");
		scanf_s("%d", &actionNum); // чтение номера действия, выбранного пользователем
		switch (actionNum) { // в зависимости от выбранного действия
		case 1:
			printf("Новое имя:");
			scanf_s("%s", db.name, 10); // чтение нового значения имени из консоли и сохранение в поле имени переменной db
			break;
		case 2:
			printf("Новая фамилия:");
			scanf_s("%s", db.surname, 10); // чтение нового значения фамилии из консоли и сохранение в поле фамилии переменной db
			break;
		case 3:
			printf("Новый номер:");
			scanf_s("%d", &db.phone); // чтение нового значения телефонного номера из консоли и сохранение в поле телефонного номера переменной db
			break;
		}
	} while (actionNum > 3 || actionNum < 0); // повторяем цикл, если пользователь ввел некорректный номер действия

	fwrite(&db, sizeof(person), 1, f); // запись нового значения полей изменяемой записи в файл f
}



void deleteLineDB(FILE* f, int* dbSize) { // функция удаления строчки из базы данных f
	int lineNum; // переменная, которая хранит номер удаляемой строчки
	person t; // переменная типа person, которая используется для перезаписи значений записей в файле f
	printf("Укажите номер строчки:"); // вывод сообщения на экран, запрашивающего номер удаляемой строчки
	scanf_s("%d", &lineNum); // чтение номера удаляемой строчки, введенного пользователем, и сохранение в переменной lineNum
	fseek(f, sizeof(person) * lineNum, SEEK_SET); // перемещение указателя файла на начало удаляемой записи
	for (int i = 0; i < *dbSize - lineNum; i++) { // цикл, который используется для сдвига всех записей после удаляемой на одну позицию назад
		fread(&t, sizeof(person), 1, f); // чтение значения текущей записи из файла f в переменную t
		fseek(f, -48, SEEK_CUR); // перемещение указателя файла на начало текущей записи
		fwrite(&t, sizeof(person), 1, f); // запись значения текущей записи в файл f
		fseek(f, sizeof(person), SEEK_CUR); // перемещение указателя файла на начало следующей записи
	}
	*dbSize = *dbSize - 1; // уменьшение значения переменной dbSize на единицу для отражения нового размера базы данных после удаления записи
}



void sortDB(FILE* f, int dbSize, int sortingColumn) { // функция сортировки базы данных f по столбцу sortingColumn
	char** t = new char* [dbSize]; // создание динамического массива t, который будет содержать временные значения сортируемого столбца
	person db; // создание переменной db типа person, которая будет использоваться для чтения данных из файла f
	fseek(f, 0, SEEK_SET); // перемещаем указатель файла на начало

	// Цикл для чтения базы данных и копирования временных значений в t
	for (int i = 0; i < dbSize; i++) {
		char* temp = new char[10]; // временный массив для хранения строки для текущей записи (имени, фамилии или телефона)
		fread(&db, sizeof(person), 1, f); // чтение данных из файла f в переменную db
		switch (sortingColumn) { // в зависимости от выбранного столбца для сортировки
		case 1: // если выбран столбец имен
			for (int j = 0; j < 10; j++) temp[j] = db.name[j]; // копируем имя из db в temp
			break;
		case 2: // если выбран столбец фамилий
			for (int j = 0; j < 10; j++) temp[j] = db.surname[j]; // копируем фамилию из db в temp
			break;
		case 3: // если выбран столбец телефонных номеров
			for (int j = 0; j < 10; j++) temp[j] = '0'; // заполняем temp нулями
			int e = db.phone, n = 0; // создаем переменные e и n, которые будут использоваться для определения количества цифр в телефонном номере
			while (e) { // пока e не равно нулю
				e /= 10; // уменьшаем значение e на один разряд
				n++; // увеличиваем значение n на единицу
			}
			e = db.phone; // возвращаем значение e
			for (int j = 0; j < n; j++) { // для каждой цифры в телефонном номере
				temp[9 - j] = temp[9 - j] + e % 10; // копируем ее в массив temp (в обратном порядке)
				e /= 10; // уменьшаем значение e на один разряд
			}
			t[i] = temp; // записываем значение temp в массив t
			break;
		}
		t[i] = temp; // записываем значение temp в массив t
	}

	char flag; // флаг, который используется для определения того, были ли произведены какие-либо сортировки на текущей итерации цикла
	// Цикл, который использует алгоритм пузырьковой сортировки для сортировки значений в массиве t
	for (int i = 0; i < dbSize - 1; i++) {
		flag = 1; // устанавливаем флаг в true

		for (int j = 0; j < dbSize - i - 1; j++) { // для каждой пары значений в массиве t
			int k = 0;
			fseek(f, sizeof(person) * j, SEEK_SET); // перемещаем указатель файла на начало текущей записи
			while (t[j][k] == t[j + 1][k] && t[j][k] + t[j + 1][k] != 0) k++; // сравниваем значения всех цифр в текущих записях, пока не найдем первую разницу
			if (t[j][k] == 0 || t[j][k] > t[j + 1][k]) { // если текущий элемент больше следующего в массиве t
				char* p = t[j]; // меняем местами значения в массиве t
				t[j] = t[j + 1];
				t[j + 1] = p;
				person temp1, temp2;
				fread(&temp1, sizeof(person), 1, f); // читаем из файла f значения текущей записи
				fread(&temp2, sizeof(person), 1, f); // читаем из файла f значения следующей записи
				fseek(f, -48, SEEK_CUR); // перемещаем указатель файла на начало текущей записи
				fwrite(&temp2, sizeof(person), 1, f); // записываем в файл f значения следующей записи
				fwrite(&temp1, sizeof(person), 1, f); // записываем в файл f значения текущей записи
				flag = 0; // устанавливаем флаг в false
			}

		}
		if (flag) break; // если на текущей итерации не было произведено ни одной сортировки, выходим из цикла
	}


}
int main() {
	setlocale(LC_ALL, "RUS");  // установление локали на русскую
	int actionNum, size = 0;
	FILE* f;
	FILE* sizeF;
	fopen_s(&f, "DB.txt", "r+");  // открытие файла DB.txt для чтения и записи
	fopen_s(&sizeF, "size.txt", "r+");  // открытие файла size.txt для чтения и записи

	fscanf_s(sizeF, "%d", &size);  // чтение значения размера базы данных из файла size.txt

	do
	{
		puts("1. Создать новую БД\n2. Добавить запись\n3. Поиск\n4. Вывод\n5. Изменить\n6. Удалить\n7. Сортировка\n8. Выход");  // вывод в консоль меню с доступными действиями
		scanf_s("%d", &actionNum);  // считывание номера выбранного действия
		fseek(f, 0, SEEK_SET);  // перемещение указателя позиции в файле в начало
		fseek(sizeF, 0, SEEK_SET);  // перемещение указателя позиции в файле size.txt в начало
		fprintf(sizeF, "%d ", size);  // запись значения размера базы данных в файл size.txt
		switch (actionNum) {
		case 1:
			size = 0;  // обнуление размера базы данных, создание новой пустой базы данных
			break;
		case 2:
			addLineDB(f, &size);  // вызов функции добавления новой записи в базу данных
			break;
		case 3:
			findLineDB(f, size);  // вызов функции поиска записи в базе данных
			break;
		case 4:
			printDB(f, size);  // вызов функции вывода содержимого базы данных в консоль
			break;
		case 5:
			editLineDB(f, size);  // вызов функции редактирования записи в базе данных
			break;
		case 6:
			deleteLineDB(f, &size);  // вызов функции удаления записи из базы данных
			break;
		case 7:
			int columnNum;  // объявление переменной для номера столбца, по которому будет сортироваться база данных
			printf("Укажите столбец по которому сортировать\n1)Имя\n2)Фамилия\n3)Номер\n");  // вывод доступных столбцов для сортировки
			do {
				printf(":");
				scanf_s("%d", &columnNum);  // считывание номера выбранного столбца
			} while (columnNum > 3 || columnNum < 0);  // проверка на корректность выбора
			sortDB(f, size, columnNum);  // вызов функции для сортировки базы данных по выбранному столбцу
			break;
		}
	} while (actionNum != 8);  // повторение цикла до тех пор, пока пользователь не выберет действие "Выход"

	return 0;
}